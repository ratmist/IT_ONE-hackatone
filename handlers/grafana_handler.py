import requests
from urllib.parse import urljoin
import copy
import time

class GrafanaHandler:
    def __init__(self, grafana_host: str, grafana_key: str, org_id: int | None = None, timeout_sec: int = 15):
        self.grafana_host = grafana_host.rstrip("/")
        self.grafana_key = grafana_key
        self.timeout = timeout_sec
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"{self.grafana_key}",
        }
        if org_id is not None:
            self.headers["X-Grafana-Org-Id"] = str(org_id)

    def _abs(self, path: str) -> str:
        return urljoin(self.grafana_host + "/", path.lstrip("/"))

    def _dash_link(self, url_from_api: str | None) -> str | None:
        if not url_from_api:
            return None
        return urljoin(self.grafana_host + "/", url_from_api.lstrip("/"))

    def fetch_datasources(self):
        url = self._abs("/api/datasources")
        resp = requests.get(url, headers=self.headers, timeout=self.timeout)
        if resp.status_code == 200:
            processed_ds = []
            for ds in resp.json():
                match ds.get("typeName"):
                    case "Prometheus":
                        modified = ds.copy()
                        modified["uid"] = ds.get("uid", "")
                        modified["name"] = str.lower(ds.get("typeName", ""))
                        processed_ds.append(modified)
                    case "PostgreSQL":
                        modified = ds.copy()
                        modified["uid"] = ds.get("uid", "")
                        modified["name"] = str.lower(ds.get("typeName", ""))
                        processed_ds.append(modified)
                    case _:
                        pass
            return processed_ds
        return []

    def get_dashboard_by_uid(self, uid: str):
        url = self._abs(f"/api/dashboards/uid/{uid}")
        resp = requests.get(url, headers=self.headers, timeout=self.timeout)
        if resp.status_code == 200:
            return resp.json()
        return None

    def delete_dashboard_by_uid(self, uid: str):
        url = self._abs(f"/api/dashboards/uid/{uid}")
        resp = requests.delete(url, headers=self.headers, timeout=self.timeout)
        return resp.status_code in (200, 202)

    @staticmethod
    def _sanitize_dashboard_json(raw: dict) -> dict:
        d = copy.deepcopy(raw)
        if "id" in d and d["id"] not in (None, 0):
            d.pop("id", None)
        uid = d.get("uid")
        if uid is not None and not isinstance(uid, str):
            d["uid"] = str(uid)

        d.setdefault("schemaVersion", 36)
        d.setdefault("timezone", "browser")
        d.setdefault("time", {"from": "now-1h", "to": "now"})        
        d.setdefault("title", "Generated Dashboard")
        return d

    def apply_dashboard(self, dashboard_json: dict, folder_id: int = 0, allow_delete_on_conflict: bool = True):
        url = self._abs("/api/dashboards/db")
        sanitized = self._sanitize_dashboard_json(dashboard_json)
        payload = {
            "dashboard": sanitized,
            "overwrite": True,
            "folderId": folder_id,
            "message": "Auto-generated by Prometheus Viewer",
        }

        try:
            resp = requests.post(url, json=payload, headers=self.headers, timeout=self.timeout)
            if resp.status_code in (200, 201):
                data = resp.json()
                link = self._dash_link(data.get("url"))
                data["url"] = link or ""
                return data
            if resp.status_code == 412:
                uid = sanitized.get("uid")
                if allow_delete_on_conflict and uid:
                    deleted = self.delete_dashboard_by_uid(uid)
                    if not deleted:
                        return {"error": "API Error 412 (conflict)", "details": f"Failed to delete existing dashboard uid={uid}. Response: {resp.text}"}
                    time.sleep(0.5)
                    retry = requests.post(url, json=payload, headers=self.headers, timeout=self.timeout)
                    if retry.status_code in (200, 201):
                        data = retry.json()
                        link = self._dash_link(data.get("url"))
                        data["url"] = link or ""
                        return data
                    else:
                        return {"error": f"API Error {retry.status_code} after delete+retry", "details": retry.text}
                else:
                    return {"error": "API Error 412 (conflict)", "details": resp.text}
            return {"error": f"API Error {resp.status_code}", "details": resp.text}
        except Exception as e:
            return {"error": str(e)}